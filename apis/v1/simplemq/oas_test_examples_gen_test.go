// Code generated by ogen, DO NOT EDIT.

package simplemq

import (
	"github.com/go-faster/jx"

	std "encoding/json"
	"testing"

	"github.com/stretchr/testify/require"
)

func TestDeleteMessageBadRequest_EncodeDecode(t *testing.T) {
	var typ DeleteMessageBadRequest
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DeleteMessageBadRequest
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDeleteMessageInternalServerError_EncodeDecode(t *testing.T) {
	var typ DeleteMessageInternalServerError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DeleteMessageInternalServerError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDeleteMessageNotFound_EncodeDecode(t *testing.T) {
	var typ DeleteMessageNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DeleteMessageNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDeleteMessageOK_EncodeDecode(t *testing.T) {
	var typ DeleteMessageOK
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DeleteMessageOK
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDeleteMessageUnauthorized_EncodeDecode(t *testing.T) {
	var typ DeleteMessageUnauthorized
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DeleteMessageUnauthorized
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestError_EncodeDecode(t *testing.T) {
	var typ Error
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Error
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestExtendMessageTimeoutBadRequest_EncodeDecode(t *testing.T) {
	var typ ExtendMessageTimeoutBadRequest
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ExtendMessageTimeoutBadRequest
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestExtendMessageTimeoutInternalServerError_EncodeDecode(t *testing.T) {
	var typ ExtendMessageTimeoutInternalServerError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ExtendMessageTimeoutInternalServerError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestExtendMessageTimeoutNotFound_EncodeDecode(t *testing.T) {
	var typ ExtendMessageTimeoutNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ExtendMessageTimeoutNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestExtendMessageTimeoutOK_EncodeDecode(t *testing.T) {
	var typ ExtendMessageTimeoutOK
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ExtendMessageTimeoutOK
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestExtendMessageTimeoutUnauthorized_EncodeDecode(t *testing.T) {
	var typ ExtendMessageTimeoutUnauthorized
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ExtendMessageTimeoutUnauthorized
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestMessage_EncodeDecode(t *testing.T) {
	var typ Message
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Message
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestMessageContent_EncodeDecode(t *testing.T) {
	var typ MessageContent
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 MessageContent
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestMessageId_EncodeDecode(t *testing.T) {
	var typ MessageId
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 MessageId
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestNewMessage_EncodeDecode(t *testing.T) {
	var typ NewMessage
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 NewMessage
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestReceiveMessageBadRequest_EncodeDecode(t *testing.T) {
	var typ ReceiveMessageBadRequest
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ReceiveMessageBadRequest
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestReceiveMessageInternalServerError_EncodeDecode(t *testing.T) {
	var typ ReceiveMessageInternalServerError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ReceiveMessageInternalServerError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestReceiveMessageOK_EncodeDecode(t *testing.T) {
	var typ ReceiveMessageOK
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ReceiveMessageOK
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestReceiveMessageUnauthorized_EncodeDecode(t *testing.T) {
	var typ ReceiveMessageUnauthorized
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ReceiveMessageUnauthorized
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSendMessageBadRequest_EncodeDecode(t *testing.T) {
	var typ SendMessageBadRequest
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SendMessageBadRequest
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSendMessageInternalServerError_EncodeDecode(t *testing.T) {
	var typ SendMessageInternalServerError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SendMessageInternalServerError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSendMessageOK_EncodeDecode(t *testing.T) {
	var typ SendMessageOK
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SendMessageOK
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSendMessageUnauthorized_EncodeDecode(t *testing.T) {
	var typ SendMessageUnauthorized
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SendMessageUnauthorized
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSendRequest_EncodeDecode(t *testing.T) {
	var typ SendRequest
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SendRequest
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
