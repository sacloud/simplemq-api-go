// Code generated by ogen, DO NOT EDIT.

package queue

import (
	"fmt"

	"github.com/go-faster/errors"
	"github.com/go-faster/jx"

	"github.com/ogen-go/ogen/validate"

	std "encoding/json"
	"testing"

	"github.com/stretchr/testify/require"
)

func TestClearQueueBadRequest_EncodeDecode(t *testing.T) {
	var typ ClearQueueBadRequest
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ClearQueueBadRequest
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestClearQueueInternalServerError_EncodeDecode(t *testing.T) {
	var typ ClearQueueInternalServerError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ClearQueueInternalServerError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestClearQueueNotFound_EncodeDecode(t *testing.T) {
	var typ ClearQueueNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ClearQueueNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestClearQueueOK_EncodeDecode(t *testing.T) {
	var typ ClearQueueOK
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ClearQueueOK
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestClearQueueOKSimpleMQ_EncodeDecode(t *testing.T) {
	var typ ClearQueueOKSimpleMQ
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ClearQueueOKSimpleMQ
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestClearQueueUnauthorized_EncodeDecode(t *testing.T) {
	var typ ClearQueueUnauthorized
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ClearQueueUnauthorized
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCommonServiceItem_EncodeDecode(t *testing.T) {
	var typ CommonServiceItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CommonServiceItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCommonServiceItemDescription_EncodeDecode(t *testing.T) {
	var typ CommonServiceItemDescription
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CommonServiceItemDescription
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCommonServiceItemID_EncodeDecode(t *testing.T) {
	var typ CommonServiceItemID
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CommonServiceItemID
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestConfigQueueBadRequest_EncodeDecode(t *testing.T) {
	var typ ConfigQueueBadRequest
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ConfigQueueBadRequest
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestConfigQueueInternalServerError_EncodeDecode(t *testing.T) {
	var typ ConfigQueueInternalServerError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ConfigQueueInternalServerError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestConfigQueueNotFound_EncodeDecode(t *testing.T) {
	var typ ConfigQueueNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ConfigQueueNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestConfigQueueOK_EncodeDecode(t *testing.T) {
	var typ ConfigQueueOK
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ConfigQueueOK
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestConfigQueueRequest_EncodeDecode(t *testing.T) {
	var typ ConfigQueueRequest
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ConfigQueueRequest
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestConfigQueueRequestCommonServiceItem_EncodeDecode(t *testing.T) {
	var typ ConfigQueueRequestCommonServiceItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ConfigQueueRequestCommonServiceItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestConfigQueueUnauthorized_EncodeDecode(t *testing.T) {
	var typ ConfigQueueUnauthorized
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ConfigQueueUnauthorized
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCreateQueueBadRequest_EncodeDecode(t *testing.T) {
	var typ CreateQueueBadRequest
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CreateQueueBadRequest
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCreateQueueConflict_EncodeDecode(t *testing.T) {
	var typ CreateQueueConflict
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CreateQueueConflict
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCreateQueueCreated_EncodeDecode(t *testing.T) {
	var typ CreateQueueCreated
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CreateQueueCreated
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCreateQueueInternalServerError_EncodeDecode(t *testing.T) {
	var typ CreateQueueInternalServerError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CreateQueueInternalServerError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCreateQueueRequest_EncodeDecode(t *testing.T) {
	var typ CreateQueueRequest
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CreateQueueRequest
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCreateQueueRequestCommonServiceItem_EncodeDecode(t *testing.T) {
	var typ CreateQueueRequestCommonServiceItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CreateQueueRequestCommonServiceItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCreateQueueRequestCommonServiceItemProvider_EncodeDecode(t *testing.T) {
	var typ CreateQueueRequestCommonServiceItemProvider
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CreateQueueRequestCommonServiceItemProvider
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCreateQueueRequestCommonServiceItemProviderClass_EncodeDecode(t *testing.T) {
	var typ CreateQueueRequestCommonServiceItemProviderClass
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CreateQueueRequestCommonServiceItemProviderClass
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCreateQueueUnauthorized_EncodeDecode(t *testing.T) {
	var typ CreateQueueUnauthorized
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CreateQueueUnauthorized
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDeleteQueueBadRequest_EncodeDecode(t *testing.T) {
	var typ DeleteQueueBadRequest
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DeleteQueueBadRequest
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDeleteQueueInternalServerError_EncodeDecode(t *testing.T) {
	var typ DeleteQueueInternalServerError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DeleteQueueInternalServerError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDeleteQueueNotFound_EncodeDecode(t *testing.T) {
	var typ DeleteQueueNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DeleteQueueNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDeleteQueueOK_EncodeDecode(t *testing.T) {
	var typ DeleteQueueOK
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DeleteQueueOK
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDeleteQueueUnauthorized_EncodeDecode(t *testing.T) {
	var typ DeleteQueueUnauthorized
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DeleteQueueUnauthorized
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestError_EncodeDecode(t *testing.T) {
	var typ Error
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Error
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestError_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"error_code\":\"bad_request\",\"error_msg\":\"不適切な要求です。パラメータの指定誤り、入力規則違反です。入力内容をご確認ください。\",\"is_fatal\":true,\"serial\":\"749ad39e1eea340c4d75bf5a4dd4bd11\",\"status\":\"400 Bad Request\"}"},
		{Input: "{\"error_code\":\"conflict\",\"error_msg\":\"要求された操作を行えません。現在の対象の状態では、この操作を受け付けできません。\\nsame queue name found\",\"is_fatal\":true,\"serial\":\"749ad39e1eea340c4d75bf5a4dd4bd11\",\"status\":\"409 Conflict\"}"},
		{Input: "{\"error_code\":\"not_found\",\"error_msg\":\"対象が見つかりません。対象は利用できない状態か、IDまたはパスに誤りがあります。\",\"is_fatal\":true,\"serial\":\"749ad39e1eea340c4d75bf5a4dd4bd11\",\"status\":\"404 Not Found\"}"},
		{Input: "{\"error_code\":\"unauthorized\",\"error_msg\":\"error-unauthorized\",\"is_fatal\":true,\"serial\":\"749ad39e1eea340c4d75bf5a4dd4bd11\",\"status\":\"401 Unauthorized\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ Error

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 Error
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestExpireSeconds_EncodeDecode(t *testing.T) {
	var typ ExpireSeconds
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ExpireSeconds
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetMessageCountBadRequest_EncodeDecode(t *testing.T) {
	var typ GetMessageCountBadRequest
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetMessageCountBadRequest
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetMessageCountInternalServerError_EncodeDecode(t *testing.T) {
	var typ GetMessageCountInternalServerError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetMessageCountInternalServerError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetMessageCountNotFound_EncodeDecode(t *testing.T) {
	var typ GetMessageCountNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetMessageCountNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetMessageCountOK_EncodeDecode(t *testing.T) {
	var typ GetMessageCountOK
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetMessageCountOK
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetMessageCountOKSimpleMQ_EncodeDecode(t *testing.T) {
	var typ GetMessageCountOKSimpleMQ
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetMessageCountOKSimpleMQ
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetMessageCountUnauthorized_EncodeDecode(t *testing.T) {
	var typ GetMessageCountUnauthorized
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetMessageCountUnauthorized
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetQueueBadRequest_EncodeDecode(t *testing.T) {
	var typ GetQueueBadRequest
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetQueueBadRequest
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetQueueInternalServerError_EncodeDecode(t *testing.T) {
	var typ GetQueueInternalServerError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetQueueInternalServerError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetQueueNotFound_EncodeDecode(t *testing.T) {
	var typ GetQueueNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetQueueNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetQueueOK_EncodeDecode(t *testing.T) {
	var typ GetQueueOK
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetQueueOK
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetQueueUnauthorized_EncodeDecode(t *testing.T) {
	var typ GetQueueUnauthorized
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetQueueUnauthorized
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetQueuesBadRequest_EncodeDecode(t *testing.T) {
	var typ GetQueuesBadRequest
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetQueuesBadRequest
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetQueuesInternalServerError_EncodeDecode(t *testing.T) {
	var typ GetQueuesInternalServerError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetQueuesInternalServerError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetQueuesOK_EncodeDecode(t *testing.T) {
	var typ GetQueuesOK
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetQueuesOK
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetQueuesUnauthorized_EncodeDecode(t *testing.T) {
	var typ GetQueuesUnauthorized
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetQueuesUnauthorized
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIcon_EncodeDecode(t *testing.T) {
	var typ Icon
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Icon
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIcon1_EncodeDecode(t *testing.T) {
	var typ Icon1
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Icon1
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIcon1ID_EncodeDecode(t *testing.T) {
	var typ Icon1ID
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Icon1ID
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestProvider_EncodeDecode(t *testing.T) {
	var typ Provider
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Provider
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestProviderClass_EncodeDecode(t *testing.T) {
	var typ ProviderClass
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ProviderClass
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestQueueName_EncodeDecode(t *testing.T) {
	var typ QueueName
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 QueueName
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestRotateAPIKeyBadRequest_EncodeDecode(t *testing.T) {
	var typ RotateAPIKeyBadRequest
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 RotateAPIKeyBadRequest
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestRotateAPIKeyInternalServerError_EncodeDecode(t *testing.T) {
	var typ RotateAPIKeyInternalServerError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 RotateAPIKeyInternalServerError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestRotateAPIKeyNotFound_EncodeDecode(t *testing.T) {
	var typ RotateAPIKeyNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 RotateAPIKeyNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestRotateAPIKeyOK_EncodeDecode(t *testing.T) {
	var typ RotateAPIKeyOK
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 RotateAPIKeyOK
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestRotateAPIKeyOKSimpleMQ_EncodeDecode(t *testing.T) {
	var typ RotateAPIKeyOKSimpleMQ
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 RotateAPIKeyOKSimpleMQ
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestRotateAPIKeyUnauthorized_EncodeDecode(t *testing.T) {
	var typ RotateAPIKeyUnauthorized
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 RotateAPIKeyUnauthorized
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSettings_EncodeDecode(t *testing.T) {
	var typ Settings
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Settings
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestStatus_EncodeDecode(t *testing.T) {
	var typ Status
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Status
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestVisibilityTimeoutSeconds_EncodeDecode(t *testing.T) {
	var typ VisibilityTimeoutSeconds
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 VisibilityTimeoutSeconds
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
